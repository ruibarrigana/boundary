# A function to generate a positive definite matrix, to be used 
# as variance-covariance matrix of the score statistic (denoted M_{0}
# in the thesis).
# Source: https://stat.ethz.ch/pipermail/r-help/2008-February/153708.html

Posdef<-function(n,ev=runif(n,0,10)) {
  Z <- matrix(ncol=n, rnorm(n^2))
  decomp <- qr(Z)
  Q <- qr.Q(decomp) 
  R <- qr.R(decomp)
  d <- diag(R)
  ph <- d / abs(d)
  O <- Q %*% diag(ph)
  Z <- t(O) %*% diag(ev) %*% O
  return(Z)
}

# For a (simplicial) cone generated by the matrix K, the next function outputs
# another matrix (matrix U) which generates the polar cone of K.
# The function 'region' below will make use of this function.
polar.cone<-function(K){
  nr_cols<-ncol(K)
  column_numbers<-1:nr_cols
  combis<-combn(column_numbers,nr_cols-1)
  combis2<-rbind(combis,combis[1,])
  U<-matrix(rep(NA,nrow(K)*nr_cols),ncol=nr_cols)
  for (i in 1:nr_cols){
    U[,i]<-Null(K[,combis2[,i]])  
    dum<-solve(K)%*%U[,i]
    if(sum(dum[column_numbers]>0)==nr_cols){ #check whether U[,i] is inside the cone (it shouldn't be)
      U[,i]<--U[,i]
    }
    if(sum(U[,i]*K[,column_numbers[-combis[,i]]])>0){ #check that the angle between U[,i] and each of the other edges of the cone is higher than 90 degrees  
      U[,i]<--U[,i]
    }
  }
  list(pc=U,combis=combis)
}



# The function 'region' which determines which region R_k
# the vector z falls into, to be used by the function 'chisq.mix' below:

region<-function(z,K,U,combis){
  
  lq<-ncol(K)
  q<-1:lq
  dum<-solve(U)%*%z
  if(sum(dum>0)==lq){
    return(0)
  }
  
  dum<-solve(K)%*%z
  if(sum(dum>0)==lq){
    return(lq)
  }
  
  for(k in 1:(lq-1)){
    combis.k.pol<-combn(q,k)
    
    for(i in 1:ncol(combis.k.pol)){
      lst<-vector("list",k)
      for(j in 1:k){
        lst[[j]]<-combis[,combis.k.pol[j,i]] 
      }
      
      UK<-cbind(U[,combis.k.pol[,i]],K[,Reduce(intersect,lst)])
      dum<-solve(UK)%*%z
      if(sum(dum>0)==lq){
        return(lq-k)
      }
    }
    
  }
  
}


# A function that returns the mixing probabilities for the chi-square
# distribution:

chisq.mix<-function(M0,lq,nz){
  
  sqL<-diag(sqrt(eigen(M0)$values))
  Pt<-t(eigen(M0)$vectors)
  sqL.Pt<-sqL%*%Pt 
  # the above matrix sqL.Pt corresponds to the square root of Lambda times P transpose.
  
  Cq<-sqL.Pt[,1:lq] # q-leftmost columns of sqL.Pt
  Cr<-sqL.Pt[,(lq+1):ncol(sqL.Pt)] # remaining columns of sqL.Pt
  X<-Cq-(Cr%*%solve(t(Cr)%*%Cr)%*%t(Cr)%*%Cq) # Cq minus its projection on the space generated by Cr,
                                              # i.e. projection of Cq on the orthogonal complement of Cr
  Sigma<-diag(svd(X)$d) # matrix Sigma from the sv decomposition of X (X=U %*% Sigma%*% V transpose)
  V_t<-t(svd(X)$v) # matrix V transpose from the sv decomposition of X
  K<-Sigma%*%V_t # the K matrix generating the simplicial cone
  U<-polar.cone(K=K)$pc
  combis<-polar.cone(K=K)$combis
  
  z<-mvrnorm(nz,rep(0,ncol(K)),diag(rep(1,ncol(K))))
  which.region<-apply(z,1,region, K=K, U=U,combis=combis)
  
  out<-rep(NA,lq+1)
  
  for(i in 0:(lq)){
    out[i+1]<-sum(which.region==i)/nz
  }
  out
}


# 'cdf.mix' Returns the cdf of the mixture of chi-square distributions with
# mixing probabilities given by input vector 'mix':

cdf.mix<-function(x,mix){
  cdfs<-rep(NA,length(mix))
  for(i in 1:length(mix)){
    cdfs[i]<-pchisq(x,i-1)
  }
  sum(mix*cdfs)
} 

# 'sq.dist' returns the squared distance of x to its projection on the parameter
# space of x, when
# x is multivariate normal with var-cov matrix equal to the inverse of M0: 

sq.dist<-function(y,x,M0){
  d<-x-y
  t(d)%*%M0%*%d
}


# 'rchisq.mix' returns 'n' simulated observations from a mixture of 
# chi-squared rv's when the mixing probabilities are given by 'mix':

rchisq.mix<-function(n,mix){
  vv<-rep(NA,n) 
  for(i in 1:n){
    ru<-runif(1)
    for(j in 1:length(mix)){
      if(ru<sum(mix[1:j])) break
    }
    vv[i]<-rchisq(1,j-1)
  } 
  vv
}

# 'rdev' returns 'n' simulated observations of the log-likelihood ratio
# statistic when the information matrix is given by M0 and
# there are 'lq' single parameters on the boundary:

rdev<-function(n,M0,lq){
  invM0<-solve(M0)
  p<-ncol(M0)
  dev<-rep(NA,n)
  for(i in 1:n){
    x<-mvrnorm(1,rep(0,p),invM0)
    alt.min<-nlminb(rep(2,p),sq.dist,x=x,M0=M0,lower=c(rep(0,lq),rep(-Inf,p-lq)),
                    upper=Inf)$objective
    null.min<-nlminb(rep(2,p),sq.dist,x=x,M0=M0,lower=c(rep(0,lq),rep(-Inf,p-lq)),
                     upper=c(rep(0,lq),rep(Inf,p-lq)))$objective
    dev[i]<-null.min-alt.min
  }
  dev
}
